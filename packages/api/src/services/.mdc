# Services Configuration

## File Structure
services/
├── interfaces/   # Service interfaces
└── impl/        # Service implementations

## Naming Conventions
Assuming the example of a `blog` API or feature, then the following convention must be satisfied:
- Implementation:
    - Implementation name: `BlogService`
    - Implementation file name: `blog.service.ts`
- Interface: 
    - Interface name: `BlogService`
    - Interface file name: `blog.service.ts`
- Methods: camelCase

## Implementation Rules
```ts
// Example of service interface
// services/interfaces/blog.service.ts
export type BlogService = {
  create(opts: { ctx: BlogAdminContext, input: BlogServiceShape['create']['input'] }): Promise<DBlogServiceShape['create']['output']>;
  list(opts: { ctx: BlogAdminContext, input: BlogServiceShape['list']['input'] }): Promise<BlogServiceShape['list']['output']>;
  get(opts: { ctx: BlogAdminContext, input: BlogServiceShape['get']['input'] }): Promise<BlogServiceShape['get']['output']>;
}

// Example service implementation
// services/impl/blog.service.ts
export const blogService: BlogService = {
  async create({ input, ctx: { blogContext: { blogRepository } } }) {
    return await blogRepository.create(input);
  },
  async list({ ctx: { blogContext: { blogRepository } } }) {
    return await blogRepository.findAll();
  },
  async get({ input, ctx: { blogContext: { blogRepository } } }) {
    const blog = await blogRepository.findById(input);
    if (!blog) {
      throw new TRPCError({
        code: 'NOT_FOUND',
        message: 'blog article not found'
      });
    }
    return blog;
  }
};

```

## Error Handling
- Use custom error classes
- Always type errors
- Log errors appropriately (use Pino when necessary)
- Return Result types
